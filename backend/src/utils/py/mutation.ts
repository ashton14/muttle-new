import { spawn } from 'child_process';
import yaml from 'js-yaml';

import { SNIPPET_FILENAME, TESTS_FILENAME, PYTHON } from '../py/pythonUtils';
import path from 'path';
import { readFile } from 'fs/promises';
import { MutatedLine, MutationOutcome, MutationStatus } from '@prisma/client';

const ModuleType = new yaml.Type('tag:yaml.org,2002:python/module:__init__', {
  kind: 'scalar',
});
const SCHEMA = yaml.DEFAULT_SCHEMA.extend(ModuleType);

export const MUTATION_RESULTS_FILENAME = path.join('reports', 'mutation.yaml');

type PartialMutatedLine = Omit<MutatedLine, 'id' | 'mutationId'> & { type?: string };

export interface Mutant {
  operator: string;
  number: number;
  addedLines: PartialMutatedLine[];
  removedLines: PartialMutatedLine[];
}

/**
 * Run mutation analysis on the given code snippet.
 * @param rootDir The root directory of the exercise. Should contain the function
 *  to be mutated in a src/__init__.py and the test cases in tests.py.
 * @param onlyCovered Whether to only mutate covered lines.
 * @returns A list of mutants generated by the mutation analysis.
 */
export const runMutationAnalysis = (
  rootDir: string,
  onlyCovered = true
): Promise<{ mutants: Mutant[], output: string }> => {
  return new Promise<{ mutants: Mutant[], output: string }>((resolve, reject) => {
    // rootDir is already the full path to the directory containing the files
    const target = path.resolve(rootDir, SNIPPET_FILENAME);
    const unitTest = path.resolve(rootDir, TESTS_FILENAME);
    const reportFile = path.resolve(rootDir, MUTATION_RESULTS_FILENAME);
    
    // Create reports directory if it doesn't exist
    const reportsDir = path.join(rootDir, 'reports');
    const fs = require('fs');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    // Create a Python script to run mutpy directly
    const pythonScript = `
import sys
import os
sys.path.append('${rootDir}')

try:
    import mutpy
    from mutpy import commandline
    
    # Use the absolute paths passed from Node.js, convert backslashes to forward slashes
    target_path = '${target.replace(/\\/g, '/')}'
    test_path = '${unitTest.replace(/\\/g, '/')}'
    report_path = '${reportFile.replace(/\\/g, '/')}'
    
    sys.argv = [
        'mutpy',
        '--target', target_path,
        '--unit-test', test_path,
        '--runner', 'pytest',
        '--report', report_path,
        '--show-mutants',
        '--colored-output'
    ]
    
    ${onlyCovered ? "sys.argv.append('--coverage')" : ''}
    
    print("RootDir:", '${rootDir}')
    print("Target:", target_path)
    print("Test:", test_path)
    print("Report:", report_path)
    print("Args:", sys.argv)
    
    # Run mutpy
    commandline.main(sys.argv)
    print("MUTPY_SUCCESS")
    
except Exception as e:
    print(f"MUTPY_ERROR: {str(e)}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
`;

    console.log('Running mutpy with script');
    console.log('RootDir:', rootDir);
    console.log('Target:', target);
    console.log('UnitTest:', unitTest);
    console.log('ReportFile:', reportFile);
    
    const python = spawn(PYTHON, ['-c', pythonScript], { cwd: rootDir });

    let output = '';
    python.stderr.on('data', chunk => {
      const data = chunk.toString();
      console.log('mutpy stderr:', data);
      output += data;
    });
    python.stdout.on('data', chunk => {
      const data = chunk.toString();
      console.log('mutpy stdout:', data);
      output += data;
    });

    python.on('close', async (code) => {
      console.log('mutpy exited with code:', code);
      console.log('Full output:', output);
      
      if (code === 0) {
        try {
          const mutatedSources = getMutatedSource(output);
          resolve({ mutants: mutatedSources, output });
        } catch (err) {
          reject(err);
        }
      } else {
        reject(new Error(`Mutpy failed with code ${code}: ${output}`));
      }
    });

    python.on('error', (err: Error) => {
      reject(err);
    });
  });
};

export type PartialMutationOutcome = Pick<
  MutationOutcome,
  | 'number'
  | 'time'
  | 'status'
  | 'testsRun'
  | 'exceptionTraceback'
  | 'mutationId'
>;

export const getMutationData = async (rootDir: string, output?: string) => {
  try {
    // Try to read from YAML file first
    console.log('Reading mutation results from:', path.join(rootDir, MUTATION_RESULTS_FILENAME));
    const resultsData = await readFile(
      path.join(rootDir, MUTATION_RESULTS_FILENAME),
      'utf-8'
    );
    console.log('Raw mutation results data length:', resultsData.length);
    console.log('Raw mutation results data:', resultsData);

    let doc: any = null;
    try {
      doc = yaml.load(resultsData, { schema: SCHEMA });
    } catch (e) {
      console.log('YAML parse error, falling back:', e);
      throw new Error('YAML parse error');
    }

    if (
      !resultsData ||
      resultsData.trim() === '' ||
      !doc ||
      !doc.mutations ||
      !Array.isArray(doc.mutations) ||
      doc.mutations.length === 0
    ) {
      console.log('YAML file is empty or has no mutations, falling back to console output parsing');
      throw new Error('No valid mutations in YAML');
    }
    
    console.log('Parsed YAML doc:', doc);
    console.log('Mutations in doc:', doc.mutations);
    
    const mutationOutcomes = doc.mutations.map((outcome: any) => {
      // The mutation analysis report from MutPy uses snake_case,
      // but the database uses camelCase. It also has some extra
      // fields.
      const { tests_run, exception_traceback, time, status, number } = outcome;
      const convertedTime = Math.round(time * 1000); // Convert seconds to milliseconds
      console.log(`Converting time for mutation ${number}: ${time}s -> ${convertedTime}ms`);
      return {
        number,
        time: convertedTime,
        status: statusToEnum(status),
        testsRun: tests_run,
        exceptionTraceback: exception_traceback,
        // operator: mutations[0].operator,
      };
    });
    
    console.log('Processed mutation outcomes from YAML:', mutationOutcomes);
    return mutationOutcomes;
  } catch (err) {
    console.log('Unable to read mutation analysis report');
    console.log('Error details:', err);
    
    // If we have output, try parsing from console output
    if (output) {
      console.log('Falling back to console output parsing');
      try {
        return parseMutationResultsFromOutput(output);
      } catch (parseErr) {
        console.log('Console output parsing also failed:', parseErr);
        throw parseErr;
      }
    }
    
    // If no output, return empty array instead of throwing
    console.log('No output available, returning empty mutation outcomes');
    return [];
  }
};

const getMutatedSource = (output: string): Mutant[] => {
  // Group 1: mutant number, Group 2: operator
  const reOperator = /^\s*-\s*\[#\s*(\d+)\]\s*(\w+)\s*__init__:\s*$/;
  // Group 1: + or -, Group 2: line number, Group 3: source
  const reMutatedLine = /^\s*(\+|-)\s(\d+):\s*(.+)$/;

  // Test the regex pattern
  const testLine = "- 2:     return x * c";
  console.log(`Testing regex on: "${testLine}"`);
  console.log(`Regex test result:`, reMutatedLine.test(testLine));
  const testMatch = reMutatedLine.exec(testLine);
  console.log(`Regex match result:`, testMatch);

  const mutants: Mutant[] = [];
  let current = -1;

  console.log('Parsing mutpy output:');
  console.log('Output lines:', output.split(/\n|\r/).length);

  // Utility to strip ANSI color codes
  const stripAnsi = (str: string) => str.replace(/\x1b\[[0-9;]*m/g, '');

  output.split(/\n|\r/).forEach((l, index) => {
    const line = stripAnsi(l);
    const trimmedLine = line.trim();
    console.log(`Line ${index}: RAW="${l}" | STRIPPED="${line}" | TRIMMED="${trimmedLine}" | length=${line.length}`);
    console.log(`Current state: current=${current}, mutants.length=${mutants.length}`);
    
    // Test the regex pattern
    const opMatches = reOperator.exec(trimmedLine);
    if (opMatches) {
      console.log(`Found operator: ${opMatches[2]} (number: ${opMatches[1]})`);
      mutants.push({} as Mutant);
      current = mutants.length - 1;
      mutants[current] = {
        operator: opMatches[2],
        number: parseInt(opMatches[1]),
        addedLines: [],
        removedLines: [],
      };
      console.log(`Set current to: ${current}`);
    } else if (trimmedLine.includes('[#') && trimmedLine.includes(']') && trimmedLine.includes('__init__:')) {
      // Fallback pattern for debugging
      console.log(`Line contains operator pattern but regex didn't match: "${trimmedLine}"`);
      console.log(`Regex test:`, reOperator.test(trimmedLine));
      
      // Try a simpler pattern
      const simpleMatch = trimmedLine.match(/\[#\s*(\d+)\]\s*(\w+)/);
      if (simpleMatch) {
        console.log(`Simple match found: ${simpleMatch[2]} (number: ${simpleMatch[1]})`);
        mutants.push({} as Mutant);
        current = mutants.length - 1;
        mutants[current] = {
          operator: simpleMatch[2],
          number: parseInt(simpleMatch[1]),
          addedLines: [],
          removedLines: [],
        };
        console.log(`Set current to: ${current}`);
      }
    }

    const mutantMatches = reMutatedLine.exec(trimmedLine);
    if (mutantMatches && current >= 0) {
      console.log(`Found mutation line: ${mutantMatches[1]} ${mutantMatches[2]}: ${mutantMatches[3]}`);
      const addedOrRemoved: string = mutantMatches[1];
      const lineNumber: string = mutantMatches[2];
      const lineSource: string = mutantMatches[3];

      const newMutatedLine: PartialMutatedLine = {
        lineNo: Number(lineNumber),
        mutatedSource: lineSource,
        type: addedOrRemoved === '+' ? 'ADDED' : 'REMOVED',
      };

      const currentMutant: Mutant = mutants[current];

      if (addedOrRemoved === '+') {
        currentMutant.addedLines.push(newMutatedLine);
        console.log(`Added line to mutant ${current}:`, newMutatedLine);
      } else if (addedOrRemoved === '-') {
        currentMutant.removedLines.push(newMutatedLine);
        console.log(`Removed line from mutant ${current}:`, newMutatedLine);
      }
    } else if ((trimmedLine.includes('+') || trimmedLine.includes('-')) && trimmedLine.includes(':') && current >= 0) {
      // Debug: check if this looks like a mutation line but didn't match
      console.log(`Line looks like mutation but didn't match regex: "${trimmedLine}"`);
      console.log(`Regex test:`, reMutatedLine.test(trimmedLine));
    } else if ((trimmedLine.includes('+') || trimmedLine.includes('-')) && trimmedLine.includes(':')) {
      // Debug: check if this looks like a mutation line but current is not set
      console.log(`Line looks like mutation but current is ${current}: "${trimmedLine}"`);
      // Show character codes for debugging
      console.log(`Character codes:`, Array.from(trimmedLine).map(c => c.charCodeAt(0)));
    }
  });
  
  console.log('Final mutants:', mutants);
  return mutants;
};

const parseMutationResultsFromOutput = (output: string): PartialMutationOutcome[] => {
  // Parse mutation results from the console output
  // The output format is: [time] status by test_name
  console.log('parseMutationResultsFromOutput called with output length:', output.length);
  
  const mutationOutcomes: PartialMutationOutcome[] = [];
  const lines = output.split(/\n|\r/);
  
  // Pattern to match: [time] status by test_name
  // Examples: [0.47775 s] killed by tests.py::test_0, [0.37547 s] survived
  const resultPattern = /\[([\d.]+)\s+s\]\s+(killed|survived|incompetent|timeout)(?:\s+by\s+(.+))?/;
  
  console.log('Looking for mutation result lines in output...');
  
  lines.forEach((line, index) => {
    const trimmedLine = line.trim();
    console.log(`Checking line ${index}: "${trimmedLine}"`);
    const match = resultPattern.exec(trimmedLine);
    if (match) {
      const [, timeStr, status, testName] = match;
      console.log(`Found mutation result at line ${index}: time=${timeStr}, status=${status}, test=${testName}`);
      
      const statusEnum = statusToEnum(status);
      if (statusEnum) {
        const convertedTime = Math.round(parseFloat(timeStr) * 1000); // Convert to milliseconds
        console.log(`Converting time from output: ${timeStr}s -> ${convertedTime}ms`);
        mutationOutcomes.push({
          number: mutationOutcomes.length + 1, // Use sequential numbering
          time: convertedTime,
          status: statusEnum,
          testsRun: testName ? 1 : 0, // Count of tests run
          exceptionTraceback: null,
          mutationId: 0, // Will be set when saving to database
        });
      }
    } else if (trimmedLine.includes('[') && trimmedLine.includes('s]') && (trimmedLine.includes('killed') || trimmedLine.includes('survived'))) {
      console.log(`Line looks like mutation result but regex didn't match: "${trimmedLine}"`);
      console.log(`Regex test:`, resultPattern.test(trimmedLine));
    }
  });
  
  console.log('Parsed mutation outcomes from output:', mutationOutcomes);
  return mutationOutcomes;
};

const statusToEnum = (status: string): MutationStatus | undefined => {
  return {
    killed: MutationStatus.KILLED,
    survived: MutationStatus.SURVIVED,
    incompetent: MutationStatus.INCOMPETENT,
    timeout: MutationStatus.TIMEOUT,
  }[status];
};
